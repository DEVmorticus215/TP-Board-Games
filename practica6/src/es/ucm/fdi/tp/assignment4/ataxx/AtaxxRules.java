package es.ucm.fdi.tp.assignment4.ataxx;

import java.util.ArrayList;
import java.util.List;

import es.ucm.fdi.tp.basecode.bgame.Utils;
import es.ucm.fdi.tp.basecode.bgame.model.Board;
import es.ucm.fdi.tp.basecode.bgame.model.FiniteRectBoard;
import es.ucm.fdi.tp.basecode.bgame.model.GameError;
import es.ucm.fdi.tp.basecode.bgame.model.Game.State;
import es.ucm.fdi.tp.basecode.bgame.model.GameMove;
import es.ucm.fdi.tp.basecode.bgame.model.GameRules;
import es.ucm.fdi.tp.basecode.bgame.model.Pair;
import es.ucm.fdi.tp.basecode.bgame.model.Piece;

public class AtaxxRules implements GameRules {

	// This object is returned by gameOver to indicate that the game is not
	// over. Just to avoid creating it multiple times, etc.
	protected final Pair<State, Piece> gameInPlayResult = new Pair<State, Piece>(State.InPlay, null);

	// The dimension of the board (same rows than columns)
	private int dim;

	// The number of obstacles located in each quadrant
	private int obstacles;

	// Unique ID for all obstacle pieces
	private Piece obstacleID;

	/**
	 * AtaxxRules constructor (without arguments)
	 * <p>
	 * No obstacles are generated by default.
	 */
	public AtaxxRules() {
		this.dim = 7;
		this.obstacles = 0;
	}

	/**
	 * AtaxxRules constructor (with arguments)
	 * <p>
	 * It initialises the rules for the Ataxx game with dim rows, dim columns
	 * and obstacles number of obstacles in each quadrant randomly located.
	 */
	public AtaxxRules(int dim, int obstacles) {
		if (dim < 5) {
			throw new GameError("Dimension must be at least 5: " + dim);
		} else if (dim % 2 != 1) {
			throw new GameError("Dimension must be an odd number: " + dim);
		} else {
			this.dim = dim;
			this.obstacles = obstacles;
		}
	}

	@Override
	public String gameDesc() {
		return "Ataxx " + dim + "x" + dim;
	}

	@Override
	public Board createBoard(List<Piece> pieces) {
		Board board = new FiniteRectBoard(dim, dim);

		for (int i = 0; i < pieces.size(); i++) {
			board.setPieceCount(pieces.get(i), 2);
		}

		// Creates initial pieces up to 4 players:
		for (int i = 0; i < pieces.size(); i++) {
			if (i == 0) {
				board.setPosition(0, 0, pieces.get(i));
				board.setPosition(board.getRows() - 1, board.getCols() - 1, pieces.get(i));
			} else if (i == 1) {
				board.setPosition(0, board.getCols() - 1, pieces.get(i));
				board.setPosition(board.getRows() - 1, 0, pieces.get(i));
			} else if (i == 2) {
				board.setPosition((board.getRows() - 1) / 2, 0, pieces.get(i));
				board.setPosition((board.getRows() - 1) / 2, board.getCols() - 1, pieces.get(i));
			} else if (i == 3) {
				board.setPosition(0, (board.getCols() - 1) / 2, pieces.get(i));
				board.setPosition(board.getRows() - 1, (board.getCols() - 1) / 2, pieces.get(i));
			}
		}

		// Creates obstacles if needed:
		obstacleID = getObsPiece(pieces);

		// Checks that the user gave a resonable number of obstacles, i.e., at
		// most 10% of the board, and if not then uses the highest number of
		// obstacles allowed for the dimension provided:
		if (this.obstacles > dim * dim * 0.10) {
			this.obstacles = (int) (dim * dim * 0.10);
		}

		// Duplicates simetrically the obstacles generated in the first quadrant
		// to the others:
		int n = board.getRows() - 1;
		for (int i = 0; i < this.obstacles; i++) {
			int a = Utils.randomInt(board.getRows() / 2);
			int b = Utils.randomInt(board.getCols() / 2);

			while (board.getPosition(a, b) != null) {
				a = Utils.randomInt(board.getRows() / 2);
				b = Utils.randomInt(board.getCols() / 2);
			}

			board.setPosition(a, b, obstacleID);
			board.setPosition(a, n - b, obstacleID);
			board.setPosition(n - a, b, obstacleID);
			board.setPosition(n - a, n - b, obstacleID);
		}

		return board;
	}

	@Override
	public Piece initialPlayer(Board board, List<Piece> playersPieces) {
		// Checks the first in the list that can play (that means, that can
		// execute a valid move):

		Piece lastPlayer = playersPieces.get(playersPieces.size() - 1);

		return nextPlayer(board, playersPieces, lastPlayer);
	}

	@Override
	public int minPlayers() {
		return 2;
	}

	@Override
	public int maxPlayers() {
		return 4;
	}

	@Override
	public Pair<State, Piece> updateState(Board board, List<Piece> pieces, Piece turn) {
		// int index = pieces.indexOf(turn);
		// Piece lastPlayer = pieces.get((index + pieces.size() - 1) %
		// pieces.size());
		int n = pieces.size();

		// Checks if there are at least one valid move remaining (we have to
		// take into account that a player wins if there are remaining only
		// pieces of his type in the board or if his opponents cannot make
		// any valid moves, i.e., due to obstacles)
		for (Piece p : pieces) {
			if (validMoves(board, pieces, p).isEmpty()) {
				n--;
			}
		}

		if (board.isFull()) {
			// Keeps as winner the player with the highest number of pieces
			// located in the board:
			Piece winner = null;
			int numWinner = 0;

			State s = State.Draw;
			for (int m = 0; m < pieces.size(); m++) {
				Piece p = pieces.get(m);
				int numP = 0;

				// Counts the number of pieces of p located in the board:
				for (int i = 0; i < dim; i++) {
					for (int j = 0; j < dim; j++) {
						if (board.getPosition(i, j) == p) {
							numP++;
						}
					}
				}

				// Keeps as winner the piece p with the highest number of pieces
				// located in the board:
				if (numP > numWinner) {
					winner = p;
					numWinner = numP;
					s = State.Won;
				} else if (numP == numWinner) {
					winner = null;
					s = State.Draw;
				}
			}

			return new Pair<State, Piece>(s, winner);
		} else if (n == 1) {
			for (Piece p : pieces) {
				if (!validMoves(board, pieces, p).isEmpty()) {
					return new Pair<State, Piece>(State.Won, p);
				}
			}
			return gameInPlayResult;
		} else {
			// If there is only one player left or other players cannot make any
			// valid moves, the game stops automatically and return the player
			// left as the winner
			Piece winner = null;
			boolean onePlayerLeft = true;

			for (int i = 0; i < dim; i++) {
				for (int j = 0; j < dim; j++) {
					if (board.getPosition(i, j) != null) {
						if (winner == null) {
							winner = board.getPosition(i, j);
						}

						if (!board.getPosition(i, j).equals(winner)) {
							onePlayerLeft = false;
						}
					}
				}
			}

			if (onePlayerLeft) {
				return new Pair<State, Piece>(State.Won, winner);
			}

			return gameInPlayResult;
		}
	}

	@Override
	public Piece nextPlayer(Board board, List<Piece> playersPieces, Piece lastPlayer) {
		// Checks the next in the list that can play (that means, that can
		// execute a valid move). We use the cont variable to check all
		// playersPieces once and in case no one can execute a valid move, it
		// returns null.

		int cont = playersPieces.size();
		int i = playersPieces.indexOf(lastPlayer);
		Piece nextPlayer = playersPieces.get((i + 1) % playersPieces.size());

		List<GameMove> availableMoves = validMoves(board, playersPieces, nextPlayer);

		while (availableMoves.isEmpty()) {
			lastPlayer = nextPlayer;

			i = playersPieces.indexOf(lastPlayer);
			nextPlayer = playersPieces.get((i + 1) % playersPieces.size());

			availableMoves = validMoves(board, playersPieces, nextPlayer);
			cont--;

			if (cont == 1) {
				return null;
			}
		}

		return nextPlayer;

	}

	@Override
	public double evaluate(Board board, List<Piece> pieces, Piece turn, Piece p) {
		return 0;
	}

	@Override
	public List<GameMove> validMoves(Board board, List<Piece> playersPieces, Piece turn) {
		List<GameMove> moves = new ArrayList<GameMove>();

		// Checks origin row:
		for (int i = 0; i < board.getRows(); i++) {
			// Checks origin column:
			for (int j = 0; j < board.getCols(); j++) {
				// Checks if the piece we want to move belongs
				// to the current player:
				if (turn.equals(board.getPosition(i, j))) {
					// Checks final row:
					for (int k = i - 2; k <= i + 2; k++) {
						// Checks final column:
						for (int l = j - 2; l <= j + 2; l++) {
							// Checks if the final position where we want to
							// move the piece does exist:
							if (k >= 0 && l >= 0 && k < board.getRows() && l < board.getCols()) {
								// Checks if the final position is free:
								if (board.getPosition(k, l) == null) {
									int d = Math.max(Math.abs(i - k), Math.abs(j - l));

									// Checks if the movement is in vertical,
									// horizontal or diagonal:
									if (d == 1 || d == 2) {
										moves.add(new AtaxxMove(i, j, k, l, turn));
									}
								}
							}
						}
					}
				}
			}
		}
		return moves;
	}

	Piece getObsPiece(List<Piece> pieces) {
		int i = 0;
		Piece obs = null;

		do {
			obs = new Piece("*#" + i);
			i++;
		} while (pieces.contains(obs));

		return obs;
	}
}
